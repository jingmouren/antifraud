import networkx as nx
from itertools import combinations
import time
import sys
from math import log,ceil

def log3(x):
    return log(x)/(log(3)+0.0)


def FixedRootGreedTree(n_clique,delta):
    
    c = len(n_clique)                     
    node_set = [str(i) for i in range(c)] 
    edge_set = []                         
    n_tree_child = [item - 1 for item in n_clique]  
    
     
    edge_set.append((node_set[-1],node_set[0]))
    for i in range(c-1):
        edge_set.append((node_set[i],node_set[i+1]))
    
    degree = {}
    for item in node_set:
        degree[item] = 2      
    
    
    for i in range(c):
        current_root = node_set[i]               
        current_tree_node_num = n_tree_child[i]      
        node = []
        if current_tree_node_num > 0:
            node = [current_root + str(item) for item in range(current_tree_node_num)] 
            node.append("end")                       
        else:
            node = ["end"]
        
        
        for item in node:
            degree[item] = 0
        
        
        level_pre = current_root                
        level_next = []                         
        node_index = 0                          
        new_node_start = node[node_index]       
        flag = 0                                
        
        while True:
            for item in level_pre:
                if new_node_start != "end":
                    while degree[item] < delta:
                        if new_node_start != "end":
                            #print "true"
                            edge_set.append((item,new_node_start))
                            level_next.append(new_node_start)
                            degree[item] += 1
                            degree[new_node_start] += 1
                            node_index += 1
                            new_node_start = node[node_index]
                        else:
                            break
                else:
                    flag = 1
                    break
            if flag == 1:
                break
            level_pre = [item for item in level_next]
            level_next = []
   
     
    G = nx.Graph()
    #G.add_nodes_from(node_set)
    G.add_edges_from(edge_set)
    
    
    Path = dict(nx.shortest_path_length(G))
    
    Wiener_index = 0
    path_len_each_node = [] 
    for item in G.nodes():
        item_path_len = 0
        for item_ in G.nodes():
            Wiener_index += Path[item][item_]
            item_path_len += Path[item][item_]
        path_len_each_node.append((item,item_path_len))
    
    #print path_len_each_node
    
    
    #nx.draw(G)
    #plt.show()
    
    return Wiener_index / 2
 
def GetTheFile(min_N,max_N,file):

    cycle_size = 3
    delta = 4

    fout = open(file,'w')
    fout.write("{} {} {} {} {}\n".format("Node_number","tree1","tree2","tree3","WG"))
    
    count = 0

    for N in range(min_N,max_N):
        Node = range(1,N)
        node_set = []
        node_set = list(combinations(Node,cycle_size-1))
        n_clique_pre = []
        for item in node_set:
            temp = []
            temp.append(item[0])
            for i in range(1,cycle_size-1):
                temp.append(item[i]-item[i-1])
            temp.append(N-item[-1])
            temp.sort()
            first_k = int(ceil(log3(temp[0])))
            last_k = int(ceil(log3(temp[-1])))
            if last_k - first_k <= 3:
                n_clique_pre.append(temp)
                count += 1
        
        n_clique = []
        for item in n_clique_pre:
            if item not in n_clique:
                n_clique.append(item)

        #print len(n_clique),count
        #for item in n_clique:
        #    print int(ceil(log3(item[0]))),int(ceil(log3(item[-1])))

        wienerIndex = FixedRootGreedTree(n_clique[0],delta)
        node_distribute = n_clique[0]

        #wg = [wienerIndex]
        for item in n_clique:
            wienerIndex1 = FixedRootGreedTree(item,delta)
            #wg.append(wienerIndex1)
            if wienerIndex1 < wienerIndex:
                wienerIndex = wienerIndex1
                node_distribute = item
        
        
        fout.write("{} {} {} {} {}\n".format(N,node_distribute[0],node_distribute[1],node_distribute[2],wienerIndex))
        #print N,"real min WG: ",wienerIndex,node_distribute,"expect min WG: ",wienerIndex_exp,exp_clique[N-3]
        #if N == 20:
        #    print len(n_clique),n_clique
        #    print wg
    fout.close()
    #print FixedRootGreedTree([3,8,9],delta)

if __name__ == '__main__':
    
    min_N = int(sys.argv[1])
    max_N = int(sys.argv[2])
    file = sys.argv[3]
    t1 = time.time()
    GetTheFile(min_N,max_N,file)
    t2 = time.time()
    print(t2 - t1)
    

